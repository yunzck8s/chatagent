<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>与 LLM 对话</title>
    <style>
        /* 样式部分保持不变，这里省略以保持简洁 */
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; display: flex; justify-content: center; background-color: #f4f4f9; margin: 0; padding: 20px; box-sizing: border-box; }
        #chat-container { width: 100%; max-width: 700px; display: flex; flex-direction: column; background: #fff; border-radius: 10px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); padding: 20px; height: 90vh; }
        h1 { text-align: center; color: #333; margin: 0 0 1rem; }
        #model-selection { display: flex; gap: 1rem; margin-bottom: 1rem; }
        #provider-select, #model-select { padding: 0.5rem 1rem; border-radius: 8px; border: 1px solid #ccc; font-size: 0.9em; flex: 1; }
        #chat-box { flex-grow: 1; border: 1px solid #eaeaea; overflow-y: scroll; padding: 1rem; border-radius: 8px; background-color: #ffffff; display: flex; flex-direction: column; gap: 1rem; margin-bottom: 1rem; }
        #chat-box p { margin: 0; padding: 0.75rem 1rem; border-radius: 12px; line-height: 1.5; max-width: 85%; word-wrap: break-word; }
        .user-message { background-color: #dcf8c6; align-self: flex-end; }
        .bot-message { background-color: #f1f0f0; align-self: flex-start; }
        /* 新增：思考和工具结果的样式 */
        .thought-message { font-style: italic; color: #888; text-align: center; align-self: center; width: 90%; background-color: #fafafa; padding: 0.5rem; border-radius: 6px;}
        .tool-result-message { font-size: 0.9em; color: #333; background-color: #e3f2fd; border-left: 4px solid #2196f3; align-self: center; width: 90%; white-space: pre-wrap; }
        .tool-request-message { font-size: 0.9em; color: #333; background-color: #fff3e0; border-left: 4px solid #ff9800; align-self: center; width: 90%; }
        #input-area { display: flex; gap: 1rem; }
        #message-input { flex-grow: 1; padding: 0.75rem 1rem; border-radius: 8px; border: 1px solid #ccc; font-size: 1em; }
        #send-button { padding: 0.75rem 1.5rem; border: none; background-color: #007bff; color: white; border-radius: 8px; cursor: pointer; font-size: 1em; transition: background-color 0.2s; }
        #send-button:hover { background-color: #0056b3; }
        /* 新增：加载指示器样式 */
        .loading-indicator { color: #888; font-style: italic; }
        
        /* 工具确认对话框样式 */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.4);
        }
        
        .modal-content {
            background-color: #fefefe;
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 500px;
            border-radius: 8px;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .modal-title {
            font-size: 1.2em;
            font-weight: bold;
        }
        
        .close {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        
        .close:hover {
            color: black;
        }
        
        .modal-body {
            margin-bottom: 20px;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .form-group input, .form-group textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }
        
        .form-group textarea {
            height: 100px;
            font-family: monospace;
        }
        
        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }
        
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .btn-primary {
            background-color: #007bff;
            color: white;
        }
        
        .btn-secondary {
            background-color: #6c757d;
            color: white;
        }
        
        .btn-danger {
            background-color: #dc3545;
            color: white;
        }
        
        /* 错误消息样式 */
        .error-message {
            color: #d32f2f;
            background-color: #ffebee;
            border-left: 4px solid #d32f2f;
            align-self: center;
            width: 90%;
            padding: 10px;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div id="chat-container">
        <h1>与 LLM 对话</h1>
        <div id="model-selection">
            <select id="provider-select">
                <option value="ollama">Ollama</option>
                <option value="deepseek">DeepSeek</option>
            </select>
            <select id="model-select"></select>
        </div>
        <div id="chat-box"></div>
        <div id="input-area">
            <input type="text" id="message-input" placeholder="在这里输入你的消息...">
            <button id="send-button">发送</button>
        </div>
    </div>
    
    <!-- 工具确认对话框 -->
    <div id="tool-confirmation-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">工具执行确认</div>
                <span class="close">&times;</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>工具名称:</label>
                    <input type="text" id="tool-name" readonly>
                </div>
                <div class="form-group">
                    <label>参数:</label>
                    <textarea id="tool-arguments"></textarea>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" id="tool-reject-btn">拒绝</button>
                <button class="btn btn-primary" id="tool-approve-btn">批准并执行</button>
            </div>
        </div>
    </div>

<script>
    // --- 1. 获取页面上的元素 ---
    const chatBox = document.getElementById('chat-box');
    const messageInput = document.getElementById('message-input');
    const sendButton = document.getElementById('send-button');
    const providerSelect = document.getElementById('provider-select');
    const modelSelect = document.getElementById('model-select');
    
    // 工具确认对话框元素
    const modal = document.getElementById('tool-confirmation-modal');
    const closeModal = document.querySelector('.close');
    const toolNameInput = document.getElementById('tool-name');
    const toolArgumentsTextarea = document.getElementById('tool-arguments');
    const toolApproveBtn = document.getElementById('tool-approve-btn');
    const toolRejectBtn = document.getElementById('tool-reject-btn');

    let currentThreadId = null;
    let currentBotParagraph = null;  // 用于跟踪当前机器人的消息段落
    let pendingToolCall = null;  // 用于存储待确认的工具调用信息

    // --- 2. 模型选择逻辑 ---
    async function updateModelOptions() {
        try {
            const response = await fetch('/models');
            if (!response.ok) throw new Error('Failed to fetch models');
            const allModels = await response.json();
            const selectedProvider = providerSelect.value;
            modelSelect.innerHTML = '';
            if (allModels[selectedProvider]) {
                allModels[selectedProvider].forEach(model => {
                    const option = document.createElement('option');
                    option.value = model;
                    option.textContent = model;
                    modelSelect.appendChild(option);
                });
            } else {
                modelSelect.innerHTML = '<option disabled>No models available</option>';
            }
        } catch (error) {
            console.error('Failed to load models:', error);
            appendMessage('系统', '加载模型列表失败: ' + error.message, 'error-message');
            modelSelect.innerHTML = '<option disabled>Error loading models</option>';
        }
    }

    // --- 3. 绑定事件 ---
    sendButton.addEventListener('click', sendMessage);
    messageInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') sendMessage();
    });
    providerSelect.addEventListener('change', updateModelOptions);
    document.addEventListener('DOMContentLoaded', updateModelOptions);
    
    // 工具确认对话框事件
    closeModal.onclick = function() {
        modal.style.display = "none";
    }
    
    window.onclick = function(event) {
        if (event.target == modal) {
            modal.style.display = "none";
        }
    }
    
    toolApproveBtn.onclick = function() {
        confirmToolExecution(true);
    }
    
    toolRejectBtn.onclick = function() {
        confirmToolExecution(false);
    }

    // --- 4. 核心发送消息函数 ---
    async function sendMessage() {
        const userMessage = messageInput.value.trim();
        if (!userMessage) return;

        appendMessage('你', userMessage, 'user-message');
        messageInput.value = '';

        // 创建机器人的消息段落
        currentBotParagraph = appendMessage('机器人', '', 'bot-message', true);

        await fetchAndProcessStream('/chat', {
            text: userMessage,
            provider: providerSelect.value,
            model: modelSelect.value,
            thread_id: currentThreadId
        }, currentBotParagraph);
    }

    // --- 5. 流式处理函数 (已更新以适配 create_react_agent) ---
    async function fetchAndProcessStream(endpoint, body, botParagraphElement) {
        try {
            const response = await fetch(endpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body),
            });

            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            botParagraphElement.innerHTML = '<strong>机器人:</strong> '; // 清空占位符

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                const chunk = decoder.decode(value, { stream: true });
                const lines = chunk.split('\n\n');

                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        const jsonData = JSON.parse(line.substring(6));

                        // 保存或更新会话ID
                        if (jsonData.thread_id && !currentThreadId) {
                            currentThreadId = jsonData.thread_id;
                        }

                        // **核心：根据新的消息类型来显示内容**
                        if (jsonData.type === 'content') {
                            // 添加内容到当前机器人的消息段落
                            botParagraphElement.innerHTML += jsonData.content.replace(/\n/g, '<br>');
                        } else if (jsonData.type === 'thought') {
                            // 对于思考消息，创建新的段落
                            appendMessage('思考', jsonData.content, 'thought-message');
                        } else if (jsonData.type === 'tool_result') {
                            const formattedResult = `执行结果:\n${String(jsonData.content).substring(0, 300)}...`; // 截断过长的结果
                            appendMessage('工具', formattedResult, 'tool-result-message');
                        } else if (jsonData.type === 'tool_request') {
                            // 显示工具请求消息
                            appendMessage('工具请求', `请求调用工具: ${jsonData.tool_name}`, 'tool-request-message');
                            
                            // 显示工具确认对话框
                            showToolConfirmationDialog(jsonData);
                        }
                        scrollToBottom();
                    }
                }
            }
        } catch (error) {
            console.error('Error:', error);
            appendMessage('系统', '请求处理过程中发生错误: ' + error.message, 'error-message');
            botParagraphElement.innerHTML += '<span style="color: red;">抱歉，出错了。请检查后端服务是否正常。</span>';
        } finally {
            // 流结束时重置当前机器人段落引用
            currentBotParagraph = null;
        }
    }

    // --- 6. 工具确认对话框函数 ---
    function showToolConfirmationDialog(toolData) {
        console.log('Showing tool confirmation dialog with data:', toolData);
        try {
            pendingToolCall = {
                tool_name: toolData.tool_name,
                arguments: toolData.arguments,
                thread_id: toolData.thread_id
            };
            
            toolNameInput.value = toolData.tool_name;
            toolArgumentsTextarea.value = JSON.stringify(toolData.arguments, null, 2);
            
            modal.style.display = "block";
        } catch (error) {
            console.error('Error showing tool confirmation dialog:', error);
            appendMessage('系统', '显示工具确认对话框时出错: ' + error.message, 'error-message');
        }
    }
    
    async function confirmToolExecution(approved) {
        console.log('Confirming tool execution:', approved, 'for call:', pendingToolCall);
        if (!pendingToolCall) {
            console.warn('No pending tool call to confirm');
            appendMessage('系统', '没有待确认的工具调用', 'error-message');
            return;
        }
        
        try {
            const response = await fetch('/continue_thread', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    thread_id: pendingToolCall.thread_id,
                    approved: approved,
                    tool_calls: approved ? [{
                        name: pendingToolCall.tool_name,
                        args: JSON.parse(toolArgumentsTextarea.value)
                    }] : null
                })
            });
            
            const result = await response.json();
            console.log('Tool confirmation result:', result);
            
            if (result.status === 'success') {
                appendMessage('系统', `工具 ${pendingToolCall.tool_name} 已${approved ? '批准' : '拒绝'}执行`, 'thought-message');
                // 显示工具执行结果
                if (result.result && approved) {
                    const formattedResult = `执行结果:\n${String(result.result).substring(0, 300)}...`;
                    appendMessage('工具', formattedResult, 'tool-result-message');
                }
                
                // 显示最终的AI响应
                if (result.final_response && approved) {
                    // 创建新的机器人消息段落来显示最终响应
                    const botParagraph = appendMessage('机器人', '', 'bot-message', true);
                    botParagraph.innerHTML += result.final_response.replace(/\n/g, '<br>');
                }
            } else {
                appendMessage('系统', `工具确认失败: ${result.message}`, 'error-message');
            }
        } catch (error) {
            console.error('Tool confirmation error:', error);
            appendMessage('系统', '工具确认过程中发生错误: ' + error.message, 'error-message');
        }
        
        // 关闭对话框
        modal.style.display = "none";
        pendingToolCall = null;
    }

    // --- 7. 辅助函数 ---
    function appendMessage(user, text, className, isPlaceholder = false) {
        try {
            const p = document.createElement('p');
            p.className = className;
            const strong = document.createElement('strong');
            strong.textContent = `${user}: `;
            p.appendChild(strong);
            if (!isPlaceholder) {
               p.innerHTML += text.replace(/\n/g, '<br>');
            }
            chatBox.appendChild(p);
            scrollToBottom();
            return p;
        } catch (error) {
            console.error('Error in appendMessage:', error);
        }
    }

    function scrollToBottom() {
        try {
            chatBox.scrollTop = chatBox.scrollHeight;
        } catch (error) {
            console.error('Error scrolling to bottom:', error);
        }
    }
</script>
</body>
</html>